WeatherApplication (Spring Boot Entry)
        │
        ▼
WeatherController ──> WeatherService (Interface)
        │                  │
        │                  ▼
        │           WeatherServiceImpl
        │                  │
        │      ┌───────────┴───────────┐
        │      │                       │
        │      ▼                       ▼
        │  KmaGridConverter       WebClient (API 호출)
        │      │                       │
        │      ▼                       ▼
        │   격자 좌표(nx, ny)      기상청 OBS API (XML)
        │                              │
        │                              ▼
        │                     XML → WeatherItem List
        │                              │
        │                              ▼
        │                     WeatherResponse 생성
        │                              │
        │              ┌───────────────┴───────────────┐
        │              │                               │
        ▼              ▼                               ▼
RedisTemplate (Optional 캐싱)        WeatherRepository (DB 저장)
        │                               │
        ▼                               ▼
   캐시된 WeatherResponse             Weather Entity (JPA)

주요 흐름
1. Controller
1-1) 클라이언트 요청(GPS) 수신
1-2) 유효성 검사 후 Service 호출
*유효성 검사: 사용자 입력데이터가 null 인 경우 / 올바른 형식이 아닌 경우 error 반환
*새로 배운것:
-Mono<T> : 나중에 값이 준비되면 전달될 수 있는 비동기 객체
-사용하는 이유: 일반 Spring MVC (블로킹 방식) 사용하면 서버 스레드가 API 응답이 올 때까지 기다림(blocking)
- 여러 사용자가 동시에 요청하면 스레드가 모두 대기 상태가 되어 서버 처리 능력 한계가 발생
- 외부 API 호출 같은 느린 작업이 서버 전체 성능을 막음
- 그런데 비동기 처리를 하면? 아직 데이터가 없어도, *스레드를 점유하지 않고 다른 작업 수행 가능*
> 효율적인 서버 자원 사용 가능 , 연쇄처리 가능 (Mono 체인 예: 캐시 확인 → API 호출 → DB 저장 → 응답)
> 비유하자면, Mono 를 사용하면, 편지는 아직 도착안했지만 편지함을 옆에다 두고 다른 일하면서 기다리는 것.
> 한 줄로 정리하면: 서버 스레드를 차단하지 않고, 비동기/논블로킹으로 외부 I/O(기상청 API, DB 등)를 효율적으로 처리하기 위함.

2. Service
2-1) lat/lon → 격자 좌표(nx, ny) 변환 (KmaGridConverter)
     - 기상청 초단기 실황/예보 API는 격자 좌표(nx, ny) 기준으로만 데이터를 제공하기 때문에,
     - nx, ny 로 변환. = 기상청이 사용하는 LCC 투영법(Lambert Conformal Conic) 격자 좌표.
     - git 에서 쌔벼옴

2-2) Redis 캐시 확인
  - 있으면 캐시 반환
  - 없으면 WebClient 호출 (요청인자 값음 기상청 API 허브 참고)
*Redis 캐시 선정 이유:
- 초단기 기상 실황: 30분 단위 발표
- 데이터가 크게 달라지지 않음.
- 짧은 시간 동안 같은 데이터를 여러번 요청할 수 있는데, Redis 는 조회 시간이 짧고 빠르기 때문에 선정.

*새로 배운 것: WebClient
- Spring WebFlux에서 제공하는 HTTP 비동기/논블로킹 클라이언트.
- 외부 서버(REST API, SOAP API 등)에 요청을 보내고 결과를 비동기적으로 받을 수 있음.
- 기존 Spring MVC의 RestTemplate과 비슷하지만 논블로킹, 리액티브 방식 지원.
> 사용하는 이유: 비동기 방식이기 때문에, 동시에 여러 처리가 가능. Mono<T> 와도 연결 가능.

2-3) 기상청 API(XML) 호출 → WeatherItem 리스트 변환 → WeatherResponse 생성
*새로 배운 것: XML(eXtensible Markup Language)
- 데이터를 계층적(트리 구조)으로 표현하는 텍스트 형식.
- HTML과 비슷하지만, 화면 표시용이 아니라 데이터 전달용

*새로 배운 것 2: 파싱(Parsing)
- 텍스트 형태 데이터를 프로그래밍 언어가 이해할 수 있는 구조로 변환하는 과정
- 문자열(XML) → 객체(Java Object)로 변환하는 과정.
- 여기서는 기상청 API 에서 XML 형식 DATA 를 Jackson 트리 (WeatherItem 객체) 생성하여 WeatherResponse 담아 반환.
* Jackson : Java에서 JSON/XML 데이터를 다루기 위한 라이브러리

2-4) Redis 캐시에 저장
- redisTemplate = Spring에서 제공하는 Redis 연동 객체
- opsForValue() = String(key) ↔ Object(value) 단일 값 작업 지원
 Redis 서버에 key → value 쌍으로 저장하기 때문에, 같은 key 로 get() 하면 빠르게 value 를 꺼낼 수 있다.

2-5) DB 저장(WeatherRepository 통해 Weather 엔티티 저장 가능)

3.Util / DTO / Entity

- KmaGridConverter: 위경도 ↔ 격자 좌표 변환
- DTO: GpsRequest, WeatherItem, WeatherResponse, WeatherRequest
- Entity: Weather (JPA)